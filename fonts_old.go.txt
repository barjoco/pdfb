package pdfb

import (
	"strings"

	"github.com/barjoco/utils/array"
	"github.com/barjoco/utils/log"
)

var stdFonts = []string{"courier", "helvetica", "arial", "times", "symbol", "zapfdingbats"}
var fonts = make(map[string]*Font)

// Font defines a font
// Identifier used to identify the font, eg. "RobotoMono"
// FontDir is the directory the font is in, as well as its variants
// Styles is a list of FontStyle
type Font struct {
	Identifier string
	FontDir    string
	Styles     []FontStyle
}

// FontStyle defines the name of a font style, and the name
// of the corresponding file. No need to include the .ttf part.
// The font file must be in the directory defined in Font.
// Eg. FontStyle{Name: "Thin", File: "RobotoMono-Thin"}
type FontStyle struct {
	Name string
	File string
}

// DefineFonts is used to define one or more fonts
func (p *Pdfb) DefineFonts(fonts ...Font) {
	// loop over the supplied fonts
	for _, font := range fonts {
		p.pdf.SetFontLocation(expandHome(font.FontDir))
		// fonts are stored in gofpdf using their font identifier
		// combined with the style name (to lower)
		// eg. robotomono__bold or robotomono__thin
		for _, style := range font.Styles {
			p.pdf.AddUTF8Font(strings.ToLower(font.Identifier+"__"+style.Name), "", style.File+".ttf")
		}
	}
}

// SetFont is used to set the font.
//
// fontIdentifier can be a standard font ("courier", "helvetica", "arial", "times", "symbol", "zapfdingbats")
// or a custom font that you defined using DefineFont.
//
// fontStyles are any combination of bold, italic, bolditalic, underline, and strikethrough
// Custom fonts can use 1 custom style + underline and/or strikethrough
// Standard fonts can use any combination of the styles
//
// Eg.
// SetFont("Courier", "bold", "italic", "underline", "strikethrough")
// or
// SetFont("RobotoMono", "thin", "underline", "strikethrough")
func (p *Pdfb) SetFont(fontIdentifier string, fontStyles ...string) {
	var styleStr string
	fontIdentifier = strings.ToLower(fontIdentifier)

	// check if font is one of the standard fonts or not
	if array.Contains(stdFonts, fontIdentifier) {
		for _, fontStyle := range fontStyles {
			switch strings.ToLower(fontStyle) {
			case "bold":
				styleStr += "b"
			case "italic":
				styleStr += "i"
			case "bolditalic":
				styleStr += "bi"
			case "underline":
				styleStr += "u"
			case "strikethrough":
				styleStr += "s"
			default:
				log.ErrorFatal("Invalid font style (%s) for standard font supplied to SetFont.", fontStyle)
			}
		}

		p.pdf.SetFont(fontIdentifier, styleStr, p.fontSize)
		p.fontFamily = fontIdentifier
		p.fontStyles = fontStyles

	} else {
		var isBold bool
		var isItalic bool
		var customStyle string
		for _, fontStyle := range fontStyles {
			switch strings.ToLower(fontStyle) {
			case "bold":
				isBold = true
				if customStyle == "" {
					customStyle = fontStyle
				}
			case "italic":
				isItalic = true
				if customStyle == "" {
					customStyle = fontStyle
				}
			case "underline":
				styleStr += "u"
			case "strikethrough":
				styleStr += "s"
			default:
				if customStyle == "" {
					customStyle = fontStyle
				}
			}
		}
		if isBold && isItalic {
			customStyle = "bolditalic"
		}
		if len(fontStyles) == 0 {
			log.ErrorFatal("Custom font must have at least one style in SetFont")
		}

		p.pdf.SetFont(fontIdentifier+"__"+customStyle, styleStr, p.fontSize)
		p.fontFamily = fontIdentifier
		p.fontStyles = fontStyles
	}
}

// SetFontSize ...
func (p *Pdfb) SetFontSize(fontSize float64) {
	fontSizeIncrease := fontSize / p.fontSize

	// scale lineHeight with increase/decrease of fontSize
	p.lineHeight *= fontSizeIncrease

	p.pdf.SetFontSize(fontSize)
	p.fontSize = fontSize
}
